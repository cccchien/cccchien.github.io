# -*- coding: utf-8 -*-
"""Genetic Algorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bUcWRrZJMaOSR1gy8suU7YdQxM4SCidy
"""

import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt

ticker = "AAPL"
start_date = "2025-04-08"
end_date = "2025-10-28"

data = yf.download(ticker, start=start_date, end=end_date, auto_adjust=True)
AAPL = data[['Close']].to_numpy()
plt.plot(AAPL)

def LPPL(t,A,B,C,t_c,beta,w,phi):
    return A + ( B*(t_c-t)**beta )*( 1+C*np.cos(w*np.log(t_c-t)+phi) )

def Energy(b2,T,A,B,C,D):
  return np.sum(abs(b2-(A*(T**B)+C*np.cos(D*T))))

def gene2variables(gene):
  beta = (1 + np.sum(2**np.arange(30)*gene[0:30])) / (2**30 + 1)  ##assume beta= 0 : 1/(2**30 + 1) : 1
  w = 20*( 1 + np.sum(2**np.arange(30)*gene[30:60]) )/(2**30 + 1)   ##assume w= 0 : 20/(2**30 + 1) : 20
  phi = 6.5*( 1 + np.sum(2**np.arange(30)*gene[60:90] ) )/(2**30 + 1)    ##assume phi= 0: 6.5/(2**30 + 1) : 6.5
  return beta,w,phi

## t_c happens at the last day
t_c = AAPL.shape[0] - 1 + 1e-10

import numpy as np

days = AAPL.shape[0]
log_price = np.log(AAPL)
#print(log_price)
t = np.arange(days).reshape(-1,1)
#print(t)



p=10000
r=0.02
m=500
generation=15
survive=round(p*r)


pop = np.random.randint(0,2,(p,90))
fit = np.zeros((p,1))
for gener in range(generation):
  A = np.zeros((days,3))
  for i in range(p):
    gene = pop[i,:]
    beta,w,phi = gene2variables(gene)
    for j in range(days):
      A[j,0] = 1
      A[j,1] = (t_c-t[j,0])**beta
      A[j,2] = ((t_c-t[j,0])**beta) * ( np.cos(w*np.log(t_c-t[j,0])+phi) )
    x = np.linalg.lstsq(A,log_price)[0]
    fit[i] = np.mean(abs(LPPL(t,x[0],x[1],x[2]/x[1],t_c,beta,w,phi)-log_price))


  sortf = np.argsort(fit[:,0])
  #print(np.min(fit))
  pop = pop[sortf,:]
  for i in range(survive,p):
    fid = np.random.randint(0,survive)
    mid = np.random.randint(0,survive)
    while mid==fid:
      mid = np.random.randint(0,survive)
    mask = np.random.randint(0,2,(1,90))
    son = pop[mid,:].copy()
    father = pop[fid,:]
    son[mask[0,:]==1]=father[mask[0,:]==1]
    pop[i,:]=son
  for i in range(m):
    mr = np.random.randint(survive,p)
    mc = np.random.randint(0,90)
    pop[mr,mc] = 1-pop[mr,mc]

  print("Generation ",gener," finished")

# After Evolution
for i in range(p):
  gene = pop[i,:]
  beta,w,phi = gene2variables(gene)
  for j in range(days):
    A[j,0] = 1
    A[j,1] = (t_c-t[j,0])**beta
    A[j,2] = ((t_c-t[j,0])**beta) * ( np.cos(w*np.log(t_c-t[j,0])+phi) )
  x = np.linalg.lstsq(A,log_price)[0]
  fit[i] = np.mean(abs(LPPL(t,x[0],x[1],x[2]/x[1],t_c,beta,w,phi)-log_price))

sortf = np.argsort(fit[:,0])
pop = pop[sortf,:]

gene = pop[0,:]
beta,w,phi = gene2variables(gene) ## Best
for j in range(days):
  A[j,0] = 1
  A[j,1] = (t_c-t[j,0])**beta
  A[j,2] = ((t_c-t[j,0])**beta) * ( np.cos(w*np.log(t_c-t[j,0])+phi) )
x = np.linalg.lstsq(A,log_price)[0]

## finding sum of absolute distance
SAD = np.sum(abs(LPPL(t,x[0],x[1],x[2]/x[1],t_c,beta,w,phi)-log_price))

A = x[0,0]
B = x[1,0]
C = x[2,0]/x[1,0]

synthetic=np.zeros((days,1))
for i in range(days):
  synthetic[i] = LPPL(i,A,B,C,t_c,beta,w,phi)

import matplotlib.pyplot as plt
import numpy as np

print("MIN_SAD: ",SAD, " ; A: ",A," ; B: ",B," ; C: ",C)
print("t_c: ",t_c," ; beta: ",beta," ; omega: ",w," ; phi: ",phi)

synthetic=np.zeros((days,1))
for i in range(days):
  synthetic[i] = LPPL(i,A,B,C,t_c,beta,w,phi)


plt.figure(figsize=(12,6))
plt.xlabel('t')
plt.ylabel('ln(p(t))')
plt.plot(log_price, label='Real Data',color='r')
plt.plot(synthetic, label='Synthetic Data',color='b')

plt.legend()